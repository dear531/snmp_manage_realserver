/*
 * =====================================================================================
 *
 * Filename: layer7.c
 *
 * Description: smartl7 configuration file generator.
 *
 * Version: 1.0
 * Created: 2011-08-08 10:18:38
 * Revision: none
 * Compiler: gcc
 *
 * Author: Xiaoyu Du (souldump), tingsrain@gmail.com
 * Company: 
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/types.h>
#include <limits.h>
#include <sys/wait.h>
#include <syslog.h>


#include "common/common.h"
#include "common/module.h"
#include "common/base64.h"
#include "common/dependence.h"
#include "loadbalance/apppool.h"
#include "loadbalance/vserver.h"
#include "loadbalance/rule.h"
#include "certificate/certcomm.h"
#include "certificate/certificate.h"

#include "smartrule/smartrule.h"

#include "layer7.h"

#include "logger.h"

static int print_rserver_parameter(FILE *fp, struct rserver *rserver)
{
	if (atoi(rserver->weight) > 0)
		fprintf(fp, " weight=%s", rserver->weight);

	if (atoi(rserver->maxconn) > 0)
		fprintf(fp, " maxconn=%s", rserver->maxconn);

	/* smartl7 don't care  bandwidth, if and bandwidth , smartl7 configuration can't through. */
#if 0
	if (strlen(rserver->bandwidth))
		fprintf(fp, " bandwidth=%s", rserver->bandwidth);
#endif 

	if (atoi(rserver->maxreq) > 0)
		fprintf(fp, " maxreq=%s", rserver->maxreq);

	if ((strlen(rserver->enable) && !strcmp(rserver->enable, "off")) ||
			rserver_draining_or_disabling(rserver))
		fprintf(fp, " down");
	fprintf(fp, ";\n");
	return 0;
}
/* modify@zhangly2014.9.25, for snmp protocol dynamic algrothm weight */
static int print_rserver_parameter_snmp_weght(FILE *fp, struct rserver *rserver)
{
	if (atoi(rserver->snmp_weight) > 0)
		fprintf(fp, " weight=%s", rserver->snmp_weight);

	if (atoi(rserver->maxconn) > 0)
		fprintf(fp, " maxconn=%s", rserver->maxconn);

	/* smartl7 don't care  bandwidth, if and bandwidth , smartl7 configuration can't through. */
#if 0
	if (strlen(rserver->bandwidth))
		fprintf(fp, " bandwidth=%s", rserver->bandwidth);
#endif 

	if (atoi(rserver->maxreq) > 0)
		fprintf(fp, " maxreq=%s", rserver->maxreq);

	if ((strlen(rserver->enable) && !strcmp(rserver->enable, "off")) ||
			rserver_draining_or_disabling(rserver))
		fprintf(fp, " down");
	fprintf(fp, ";\n");
	return 0;
}


static int print_rserver(FILE *fp, struct rserver *rserver, const int n)
{
	char ip[STR_IP_LEN], port[STR_PORT_LEN];
	char address[BUFSIZ];

	inet_sockaddr2ipport(&rserver->address, ip, port);
	inet_sockaddr2address(&rserver->address, address);

#define POOL_OR_BACKPOOL(fp, n) 					\
	do {							 	\
		if(atoi(port) == 0) {		 			\
			fprintf(fp, "\t\tserver\t%s", ip);		\
		} else {						\
			fprintf(fp, "\t\tserver\t%s", address);		\
		}							\
		if (n == 0) { 						\
			if (strlen(rserver->weight)) 			\
			fprintf(fp, " weight=%s", rserver->weight); 	\
			fprintf(fp, " backup;\n");			\
		} else { 						\
			print_rserver_parameter(fp, rserver); 		\
		} 							\
	} while(0) 
	POOL_OR_BACKPOOL(fp, n);
	return 0;
}


/* modify@zhangly2014.9.25, for snmp protocol dynamic algrothm weight */
static int print_rserver_snmp_weight(FILE *fp, struct rserver *rserver, const int n)
{
	char ip[STR_IP_LEN], port[STR_PORT_LEN];
	char address[BUFSIZ];

	inet_sockaddr2ipport(&rserver->address, ip, port);
	inet_sockaddr2address(&rserver->address, address);

#define POOL_OR_BACKPOOL_SNMP_WEIGHT(fp, n) 				\
	do {							 	\
		if(atoi(port) == 0) {		 			\
			fprintf(fp, "\t\tserver\t%s", ip);		\
		} else {						\
			fprintf(fp, "\t\tserver\t%s", address);		\
		}							\
		if (n == 0) { 						\
			if (strlen(rserver->snmp_weight)) 		\
			fprintf(fp, " weight=%s", rserver->snmp_weight);\
			fprintf(fp, " backup;\n");			\
		} else { 						\
			print_rserver_parameter_snmp_weght(fp, rserver);\
		} 							\
	} while(0) 
	POOL_OR_BACKPOOL_SNMP_WEIGHT(fp, n);
	return 0;
}

static int print_core_lines(FILE *fp)
{
	fprintf(fp, "#This configuration file is auto generated by scripts, "
			"do not modify it manually.\n");
	fprintf(fp, "\n");

	fprintf(fp, "user root;\n\n");
	fprintf(fp, "worker_processes 8;\n");
	fprintf(fp, "master_process on;\n");
	fprintf(fp, "catch_segv off;\n");
	fprintf(fp, "syslog local5 wisegrid;\n");

	fprintf(fp, "\n");

	fprintf(fp, "pid	/var/run/smartl7/smartl7.pid;\n");
	fprintf(fp, "error_log	/var/log/smartl7/smartl7.log error;\n");

	fprintf(fp, "\n");

	fprintf(fp, "worker_rlimit_nofile 262144;\n");

	fprintf(fp, "\n");

	return 0;
}

static int print_events_block(FILE *fp)
{
	fprintf(fp, "events {\n");
	fprintf(fp, "\tworker_connections 131072;\n");
	fprintf(fp, "\tmulti_accept on;\n");
	fprintf(fp, "}\n\n");
	return 0;
}

static void print_new_line(FILE *fp)
{
	fprintf(fp, "\n");
}

static int print_lb_algorithm(FILE *fp, char *algorithm)
{
	if (!algorithm || strlen(algorithm) == 0 )
		return -1;

	if (!strcmp(algorithm, "rr") || !strcmp(algorithm, "wrr")) {
		/** default, use round-robin **/
	} else if (!strcmp(algorithm, "lc") || !strcmp(algorithm, "wlc")) {
		fprintf(fp, "\t\tleast_conn;\n");
	} else if (!strcmp(algorithm, "fair")) {
		fprintf(fp, "\t\tfair;\n");
	} else if (!strcmp(algorithm, "hash_ip")) {
		fprintf(fp, "\t\tconsistent_hash $binary_remote_addr;\n");
	} else if (!strcmp(algorithm, "hash_url")) {
		fprintf(fp, "\t\tconsistent_hash $request_uri;\n");
	} else if (!strcmp(algorithm, "hash_cookie")) {
		fprintf(fp, "\t\tconsistent_hash $http_cookie;\n");
	} else if (!strcmp(algorithm, "least_conn")) {
		fprintf(fp, "\t\tleast_conn;\n");
	} else {
		return -1;
	}

	return 0;
}



static int print_upstream_sticky(FILE *fp, struct vserver *vs)
{
	int i;
	char hashkey[1024] = "";
	if (vs->persistent[0] == 0) {
		return 0;
	}

	if (strcmp(vs->persistent, "ip") == 0) {
		strcpy(hashkey, "hash=$binary_remote_addr");
	} else if (strcmp(vs->persistent, "ssl_id") == 0) {
		strcpy(hashkey, "hash=$ssl_session_id");
	} else if (strcmp(vs->persistent, "cookie") == 0) {
		/** default is "Set-Cookie" **/
		if (vs->persistent_cookie[0] != 0) {
			sprintf(hashkey, "name=%s", vs->persistent_cookie);
		}
	} else if (strcmp(vs->persistent, "header") == 0 && vs->persistent_header[0] != 0) {
		sprintf(hashkey, "hash=$http_%s", vs->persistent_header);
		strtolower(hashkey);
		for (i = 0; i < strlen(hashkey); i ++) {
			if (hashkey[i] == '-') {
				hashkey[i] = '_';
			}
		}
	} else {
		return -1;
	}

	if (vs->persistentgroup[0] == 0) {
		/** only persistent **/
		if (vs->timeout[0] != 0)
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=%ss;\n", 
					vs->name, hashkey, vs->timeout);
		else
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=60s;\n", 
					vs->name, hashkey);
	} else {
		if (vs->timeout[0] != 0)
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=%ss;\n", 
					vs->persistentgroup, hashkey, vs->timeout);
		else
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=60s;\n", 
					vs->persistentgroup, hashkey);
	}

	return 0;
}






static int print_upstream_block(FILE *fp, struct vserver *vs,
		struct apppool *pool, struct apppool *backpool, 
		int connreuse)
{
	struct rserver *rserver;

	int rserver_num = 0;	/** Rserver计数 **/

	if (vs == NULL || (pool == NULL && backpool == NULL)) {
		return 0;
	}

	fprintf(fp, "\tupstream %s-%s {\n", vs->name, 
			pool == NULL ? backpool -> name : pool->name);


	if (pool == NULL) {
		goto process_backpool;
	}

	list_for_each_entry(rserver, &pool->realserver_head, list) {
		if (strcmp(rserver->state, "down") == 0) {
			continue;
		}
		rserver_num ++;
		if (0 == memcmp(pool->subjoinsched, "snmp", sizeof("snmp"))) {
			print_rserver_snmp_weight(fp, rserver, 1);
		} else {
			print_rserver(fp, rserver, 1);
		}
	}

process_backpool:

	if (rserver_num == 0) {
		/** 空的应用池，填入一个默认的realserver **/
		fprintf(fp, "\t\tserver 127.0.0.1:1 weight=10;\n");
	}

	if (backpool == NULL) {
		goto process_realserver_ok;
	}

	list_for_each_entry(rserver, &backpool->realserver_head, list) {
		if (strcmp(rserver->state, "down") == 0) {
			continue;
		}
		rserver_num ++;
		if (0 == memcmp(pool->subjoinsched, "snmp", sizeof("snmp"))) {
			print_rserver_snmp_weight(fp, rserver, 1);
		} else {
			print_rserver(fp, rserver, 1);
		}
	}

process_realserver_ok:

	print_lb_algorithm(fp, vs->sched);

	if (connreuse) {
		fprintf(fp, "\t\tmultiplex 512;\n");
	}

	print_upstream_sticky(fp, vs);

	fprintf(fp, "\t}\n");
	return rserver_num;
}

/* add by fanpf */
static int print_rule_upstream_sticky(FILE *fp, struct vserver *vs, char *pool_name)
{
	int i;
	char hashkey[1024] = "";
	if (vs->persistent[0] == 0) {
		return 0;
	}

	if (strcmp(vs->persistent, "ip") == 0) {
		strcpy(hashkey, "hash=$binary_remote_addr");
	} else if (strcmp(vs->persistent, "ssl_id") == 0) {
		strcpy(hashkey, "hash=$ssl_session_id");
	} else if (strcmp(vs->persistent, "cookie") == 0) {
		/** default is "Set-Cookie" **/
		if (vs->persistent_cookie[0] != 0) {
			sprintf(hashkey, "name=%s", vs->persistent_cookie);
		}
	} else if (strcmp(vs->persistent, "header") == 0 && vs->persistent_header[0] != 0) {
		sprintf(hashkey, "hash=$http_%s", vs->persistent_header);
		strtolower(hashkey);
		for (i = 0; i < strlen(hashkey); i ++) {
			if (hashkey[i] == '-') {
				hashkey[i] = '_';
			}
		}
	} else {
		return -1;
	}

	if (vs->persistentgroup[0] == 0) {
		/** only persistent **/
		if (vs->timeout[0] != 0)
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=%ss;\n", 
					vs->name, hashkey, vs->timeout);
		else
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=60s;\n", 
					vs->name, hashkey);
	}
	/* smartrule not support persistent group now */
#if 0
	/* persistent group */
	else {
		if (vs->timeout[0] != 0)
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=%ss;\n", 
					vs->name, hashkey, vs->timeout);
		else
			fprintf(fp, "\t\tsticky group=pg_%s %s expires=60s;\n", 
					vs->persistentgroup, hashkey);
	}
#endif

	return 0;
}



/* add by fanpf for content switch */
static int print_rule_upstream_block(FILE *fp, struct vserver *vs, char *pool_name, int connreuse)
{
	struct rserver *rserver;
	int found = 0;

	if (vs == NULL) {
		return 0;
	}

	/* find pool */
	struct apppool *apppool;
	LIST_HEAD(app_head);

	int rserver_num = 0;

	module_get_queue(&app_head, "apppool", NULL);

	list_for_each_entry(apppool, &app_head, list) {
		if( !strcmp( pool_name, apppool->name)){
			found = 1;
			break;
		}
	}

	if(!found){
		module_purge_queue(&app_head, "apppool");
		return 0;
	}

	fprintf(fp, "\tupstream %s-%s {\n", vs->name, apppool->name);

	list_for_each_entry(rserver, &apppool->realserver_head, list) {
		if (strcmp(rserver->state, "down") == 0) {
			continue;
		}
		rserver_num ++;
		if (0 == memcmp(apppool->subjoinsched, "snmp", sizeof("snmp"))) {
			print_rserver_snmp_weight(fp, rserver, 1);
		} else {
			print_rserver(fp, rserver, 1);
		}
	}

	if (rserver_num == 0) {
		/** 空的应用池，填入一个默认的realserver **/
		fprintf(fp, "\t\tserver 127.0.0.1:1 weight=10;\n");
	}

	print_lb_algorithm(fp, vs->sched);

	if (connreuse) {
		fprintf(fp, "\t\tmultiplex 512;\n");
	}

	print_rule_upstream_sticky(fp, vs, apppool->name);

	module_purge_queue(&app_head, "apppool");

	fprintf(fp, "\t}\n");

	return rserver_num;
}


/**
 * 检查是否有规则对Host字段进行了重写
 * 返回值：
 *	   0: 没有重写Host的规则存在
 *	其他: 有
 **/
static int vserver_rule_check_if_Host_Modified(struct vserver *vs, 
		struct list_head *rule_head)
{
	struct rule_name *rule_name;
	struct list_head *list;
	struct rule *rule;
	char buff[128];
	char arg[BUFSIZ];
	char *ptr, *end;

	if (list_empty(&vs->rule_head))
		return 0;

	list_for_each_entry(rule_name, &vs->rule_head, list) {
		list = module_queue_search("rule", rule_head, rule_name->name);
		if (list == NULL) {
			continue;
		}
		rule = list_entry(list, struct rule, list);
		if (!strlen(rule->statements))
			continue;

		memset(buff, 0, sizeof(buff));
		base64_decode((uint8_t *)buff, rule->statements, sizeof(buff)-1);
		ptr = buff;
		while ((ptr = strstr(ptr, "http.request.addHeader")) != NULL) {
			ptr += strlen("http.request.addHeader");
			if (((ptr = strchr(ptr, '"')) != NULL) && ((end = strchr(ptr+1, '"')) != NULL)
					&& (end-ptr>1)) { 
				strncpy(arg , ptr+1, end-ptr-1);
				arg[end-ptr-1] = '\0';
				ptr+=1;
			}
			if (strcmp(arg, "Host") == 0) {
				return 1;
			}
		}
	}

	return 0;
}


/* add by fanpf, for content switch , check vserver's pools count */
static int vserver_rule_pools_num( struct vserver *vs, struct list_head *rule_head )
{ 
	struct rule_name *rule_name;
	struct list_head *list;
	struct rule *rule;
	char buff[128];
	int pools = 0;
	char *ptr;

	if (list_empty(&vs->rule_head))
		return 0;

	list_for_each_entry(rule_name, &vs->rule_head, list) {
		list = module_queue_search("rule", rule_head, rule_name->name);
		if (list == NULL) {
			continue;
		}
		rule = list_entry(list, struct rule, list);
		if (!strlen(rule->statements))
			continue;

		memset(buff, 0, sizeof(buff));
		base64_decode((uint8_t *)buff, rule->statements, sizeof(buff)-1);
		ptr = buff;
		while((ptr = strstr(ptr, "http.request.reroute")) != NULL) {
			ptr += strlen("http.request.reroute");
			pools++;
		} 
	}

	return pools;
}

static int print_rule_pools(
		FILE *fp, 
		struct vserver *vs, 
		struct list_head *rule_head, 
		int connreuse)
{
	struct apppool *pool, *pos;
	int num = 0;

	if (list_empty(&vs->rule_head))
		return 0;

	LIST_HEAD(pool_head);
	num = get_all_pools_from_vserver(&pool_head, vs);

	/* print upstream block */
	list_for_each_entry_safe(pool, pos, &pool_head, list){
		print_rule_upstream_block(fp, vs, pool->name, connreuse);
		list_del(&pool->list);
		free(pool);
	}
	return num;
}

static int signal_smartl7( char *signal, char *filename)
{
	char command[BUFSIZ];
	int ret;

	ret = system("ps -Lf -C smartl7 > /dev/null 2>&1");
	if (ret < 0 || WEXITSTATUS(ret) != 0) {
		system(NGINX_BIN_PATH);
	}

#ifdef _DEBUG
	snprintf(command, 2048, "%s -s %s -c %s", NGINX_BIN_PATH, signal, filename);
#else
	snprintf(command, 2048, "%s -s %s -c %s > /dev/null 2>&1",
			NGINX_BIN_PATH, signal, filename);
#endif
	ret = system(command);
	if (ret < 0)
		return -1;

	return (WIFEXITED(ret) && (WEXITSTATUS(ret) == EXIT_SUCCESS)) ? 0 : -1;
}



static int check_config_file(char *filename)
{
	char command[2048];
	int ret, ext_code=-1;

#ifdef _DEBUG
	snprintf(command, 2048, "%s -t -c %s", NGINX_BIN_PATH, filename);
#else
	snprintf(command, 2048, "%s -t -q -c %s > /dev/null 2>&1",
			NGINX_BIN_PATH, filename);
#endif
	ret = system(command);
	if (ret < 0){
		return -1;
	}

	/* log config flie error infomation. -- fanpf  */
	ext_code = (WIFEXITED(ret)&& ( WEXITSTATUS(ret) == EXIT_SUCCESS)) ? 0 : -1;

	if(ext_code == -1){
		log_message( LOG_TYPE_SYSTEM,  LOG_LEVEL_WARNING, NULL, \
				SMARTLOG_DAEMON4_NGINX_CONFIG_CHECK_ERROR, "七层服务配置文件服务错误，请联系管理员！"); 
	}

	return ext_code;

}

static int print_cache_path_line(FILE *fp, struct vserver *vs, int indent)
{
	int i;

	if (strcmp(vs->cache, "on"))
		return 0;

	for(i = 0; i < indent; ++i)
		fprintf(fp, "\t");

	fprintf(fp, "proxy_cache_path /data/cache/%s levels=1:2:2 keys_zone=%s:%s",
			vs->name, vs->name, 
			(strlen(vs->cache_ramsize)) ? vs->cache_ramsize : "200m");

	if (strlen(vs->cache_objnum))
		fprintf(fp, " objnum=%s", vs->cache_objnum);

	if (strlen(vs->cache_objsize))
		fprintf(fp, " objsize=%s", vs->cache_objsize);

	if (atoi(vs->cache_expire) == 0) {
		fprintf(fp, " inactive=%s", "600s");
	} else {
		fprintf(fp, " inactive=%s", vs->cache_expire);
	}

	/* default disk cache size if 500m */
	fprintf(fp, " max_size=%s", strlen(vs->cache_disksize) ?
			vs->cache_disksize : "500m");

	fprintf(fp, ";\n\n");
	return 0;
}

static int print_rewrite_rules(FILE *fp, struct vserver *vs, struct list_head *rule_head, int ident,
		int flag)
{
	if (list_empty(&vs->rule_head))
		return 0;

	++ident;

	/* request filter */
	if (smartrule_build_rules(vs, rule_head, RULE_TYPE_REQ_FILTER, ident, fp, flag) < 0) {
		return -1;
	}

	/* rewrite and reroute rules */
	if (smartrule_build_rules(vs, rule_head, RULE_TYPE_REQ_REWRITE, ident, fp, flag) < 0) {
		return -1;
	}

	/** response header filter rules **/
	if (smartrule_build_rules(vs, rule_head, RULE_TYPE_RSP_HEADER_FILTER, ident, fp, flag) < 0) {
		return -1;
	}

	/** response body filter rules **/
	if (smartrule_build_rules(vs, rule_head, RULE_TYPE_RSP_BODY_FILTER, ident, fp, flag) < 0) {
		return -1;
	}

	return 0;
}



static int check_vserver_certificate_valid(struct vserver *vserver, 
		char *certfile, char *keyfile, char *keypass, char *ca)
{
	struct certificate *c = NULL, *d = NULL;

	LIST_HEAD(certqueue);	/** 当前系统的证书列表 **/

	/** 首先获取证书列表 **/
	certificate_queue_create(&certqueue, NULL);

	if (vserver->ssl_certificate[0] == 0) {
		goto error;
	}

	if ((c = certificate_queue_search(&certqueue, vserver->ssl_certificate)) == NULL) {
		goto error;
	}

	if (certificate_get_duredate(vserver->ssl_certificate) < 0) { /** 证书过期 **/
		goto error;
	}

	if (vserver->ssl_verify_client[0] != 0) {
		if ((d = certificate_queue_search(&certqueue, 
						vserver->ssl_verify_client)) == NULL) {
			goto error;
		}
	}

	strcpy(certfile, c->certfile);
	strcpy(keyfile, c->keyfile);
	strcpy(keypass, c->password);
	if (d) {
		strcpy(ca, d->certfile);
	}

	certificate_queue_purge(&certqueue);
	return 0;

error:
	certificate_queue_purge(&certqueue);
	return -1;
}


static int check_vserver_config_valid(struct vserver *vserver)
{
	char address[BUFSIZ];
	if (strcmp(vserver->enable, "on"))	/** 关闭状态，没有启用 **/
		return -1;
	if (strncmp(vserver->protocol, "http", 4) != 0)	/** 不是http或https协议 **/
		return -1;
	if (inet_sockaddr2address(&vserver->address, address) != 0) {
		return -1;
	}
	return 0;
}

int update_config(struct list_head *vs_head, 
		struct list_head *pool_head,
		struct list_head *heathqueue,
		struct list_head *rulequeue,
		struct list_head *hbqueue,
		char *filename)
{

	struct vserver *vserver;

	char old[PATH_MAX];
	char new[PATH_MAX];
	char protocol[32];

	int ret;
	FILE *fp;
	char *ptr;

	char ip[STR_IP_LEN], port[STR_PORT_LEN];

	int valid_layer7_vserver = 0;	/** 当前有效的vserver数量 **/

	memset(old, 0, PATH_MAX);
	memset(new, 0, PATH_MAX);

	/* This is a XXX */
	ret = snprintf(old, PATH_MAX, "%s.old", filename);
	if (ret == PATH_MAX)
		return -1;

	snprintf(new, PATH_MAX, "%s.new", filename);

	fp = fopen(new, "w");
	if (!fp)
		return -1;

	setlinebuf(fp);

	/** 添加smartl7配置的基本信息设置 **/
	print_core_lines(fp);
	print_events_block(fp);
	print_new_line(fp);


	/** 扫描vserver **/
	list_for_each_entry(vserver, vs_head, list) {
		int connreuse = 0;
		int compress = 0;

		char certfile[1024] = {0};
		char keyfile[1024] = {0};
		char keypass[1024] = {0};
		char ca[1024] = {0};

		if (check_vserver_config_valid(vserver) != 0) {
			continue;
		}

		/** 如果是https协议，则检查证书 **/
		if (strcmp(vserver->protocol, "https") == 0) { 
			if (check_vserver_certificate_valid(vserver, certfile, keyfile, keypass, ca) != 0) {
				continue;
			}
		}

		if (strcmp(vserver->connreuse, "on") == 0) {
			connreuse = 1;
		}

		if (!strcmp(vserver->contentswitch, "on")) {
			if( (ret = vserver_rule_pools_num(vserver, rulequeue)) <= 0 ){
				/** 该虚拟服务器中没有应用池 **/
				continue;
			} 
		} else if (vserver->pool[0] == 0 && vserver->backpool[0] == 0) {
			/** 没有配置应用池和备份池 **/
			continue;
		}


		/** 如果是第一个vserver，需要填写 "http {" **/
		if ((++ valid_layer7_vserver) == 1) {
			fprintf(fp, "http {\n");
			fprintf(fp, "\taccess_log off;\n");
		}

		/** 填写配置文件，内容交换中所有用到的应用池 **/
		if (!strcmp(vserver->contentswitch, "on")) {
			/* add by fanpf */
			print_rule_pools(fp, vserver, rulequeue, connreuse);
		} else {
			struct apppool *apppool, *backpool;
			struct list_head *list;

			apppool = backpool = NULL;
			if ((list = module_queue_search("apppool", pool_head, 
							vserver->backpool)) != NULL) {
				backpool = list_entry(list, struct apppool, list);
			}
			if ((list = module_queue_search("apppool", pool_head, 
							vserver->pool)) != NULL) {
				apppool = list_entry(list, struct apppool, list);
			}
			if (!apppool && !backpool) {
				/** FIXME: won't reach here **/
				fprintf(fp, "\tserver {\n\t}\n}");
				continue;
			}
			print_upstream_block(fp, vserver, apppool, backpool, connreuse);
		}

		print_cache_path_line(fp, vserver, 1);

		/* syslog format must be in http block */
		if (!strcmp(vserver->log_enable, "on") && strlen(vserver->log_format)) {
			char buff[4096];
			memset(buff, 0, 4096);
			base64_decode((uint8_t *)buff, vserver->log_format, sizeof(buff)-1);
			fprintf(fp, "\t\tlog_format  %s '%s';\n", vserver->name, buff);
		}

		fprintf(fp, "\tserver {\n");
		fprintf(fp, "\t\tserver_name %s;\n", vserver->name);

		//get_ip_port(vserver->address, ip, port);
		inet_sockaddr2ipport(&vserver->address, ip, port);
		if (check_ip_version(ip) == IPV6) {
			fprintf(fp, "\t\tlisten [%s]:%s backlog=8192;\n", ip, port);
		} else {
			fprintf(fp, "\t\tlisten %s:%s backlog=8192;\n", ip, port);
		}

		print_new_line(fp);

		if (strcmp(vserver->gzip, "on") == 0) {
			fprintf(fp, "\t\tgzip on;\n");
			compress = 1;
		}

		if (strcmp(vserver->deflate, "on") == 0) {
			fprintf(fp, "\t\tdeflate on;\n");
			compress = 1;
		}

		if (compress == 1) {
			if (strcmp(vserver->cache, "on") == 0) {
				fprintf(fp, "\t\tgzip_static on;\n");
			}
			fprintf(fp, "\t\tgzip_http_version 1.1;\n");
			fprintf(fp, "\t\tgzip_vary on;\n");
			fprintf(fp, "\t\tgzip_comp_level 6;\n");
			fprintf(fp, "\t\tgzip_proxied any;\n");
			if (strlen(vserver->gzip_types) == 0) {
				fprintf(fp, "\t\tgzip_types text/plain text/css application/json "
						"application/x-javascript text/xml application/xml "
						"application/xml+rss text/javascript;\n");
			} else {
				char buff[BUFSIZ];
				memset(buff, 0, sizeof(buff));
				base64_decode((uint8_t *)buff, vserver->gzip_types, sizeof(buff)-1);
				fprintf(fp, "\t\tgzip_types %s;\n", buff);
			}
			fprintf(fp, "\t\tgzip_buffers 16 8k;\n");
			fprintf(fp, "\t\tgzip_disable \"MSIE [1-6].(?!.*SV1)\";\n");
			print_new_line(fp);
		}

		/** server - cache **/
		if (!strlen(vserver->cache)|| !strcmp(vserver->cache, "off"))
			fprintf(fp, "\t\tproxy_cache off;\n");
		else {
			fprintf(fp, "\t\tproxy_cache %s;\n", vserver->name);
			fprintf(fp, "\t\tproxy_cache_key $request_uri;\n");
			/** fprintf(fp, "\t\tproxy_ignore_headers Cache-Control Expires;\n"); **/
			fprintf(fp, "\t\tproxy_cache_valid 200 304 12h;\n");
			fprintf(fp, "\t\tproxy_cache_valid 302 301 12h;\n");
			fprintf(fp, "\t\tproxy_cache_valid any 1m;\n");
			fprintf(fp, "\t\tproxy_no_cache $cookie_nocache $arg_nocache $arg_comment;\n");
			fprintf(fp, "\t\tproxy_no_cache $http_pragma $http_authorization;\n");
			fprintf(fp, "\t\tproxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;\n");
			fprintf(fp, "\t\tproxy_cache_bypass $http_pragma $http_authorization;\n");
			print_new_line(fp);
		}

		if (!strcmp(vserver->transparent, "on")) {
			fprintf(fp, "\t\tserver_transparent on;\n");
		}

		if (atoi(vserver->maxconn) > 0) {
			fprintf(fp, "\t\tmaxconn %s;\n", vserver->maxconn);
		}
		if (atoi(vserver->maxreq) > 0) {
			fprintf(fp, "\t\tmaxreq %s;\n", vserver->maxreq);
		}

		if (!strcmp(vserver->rfc2616_check, "on")) {
			fprintf(fp, "\t\trfc2616_check on;\n");
		}

		/* syslog */
		if (!strcmp(vserver->log_enable, "on") && strlen(vserver->log_format)) {
			fprintf(fp, "\t\taccess_log  syslog:info %s;\n", vserver->name);
		}

		if (strcmp(vserver->waf_enable, "on") == 0) {
			fprintf(fp, "\t\tinclude sql.conf;\n");
		}

		print_new_line(fp);

		fprintf(fp, "\t\tlocation / {\n");
		/* add $sino_url variable */
		fprintf(fp, "\t\t\tset $sino_url $scheme://$host$request_uri;\n");
		fprintf(fp, "\t\t\tset $TRUE 1;\n");

		/** add subs_filter_types */
		fprintf(fp, "\t\t\tsubs_filter_types text/plain text/html;\n");

		/** location - proxy_set_header **/
		if (!strcmp(vserver->xforwardedfor, "on")) {
			fprintf(fp, "\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
		}

#if 0
		if (rserver_num <= 0) {
			goto only_return_404;
		}
#endif

		if (connreuse != 0) {
			fprintf(fp, "\t\t\tproxy_http_version 1.1;\n");
			fprintf(fp, "\t\t\tproxy_set_header Connection \"Keep-Alive\";\n");
		}

		/** when enable contentswitch, then Disable "gzip/deflate"-encoding to realserver **/
		if (strcmp(vserver->contentswitch, "on") == 0) {
			fprintf(fp, "\t\t\tproxy_set_header Accept-Encoding \"\";\n");
		}

		if (strlen(vserver->cipheader) != 0) {
			fprintf(fp, "\t\t\tproxy_set_header %s $remote_addr;\n", vserver->cipheader);
		}

		/** 
		 * Note: 添加proxy_set_header Host $host的时机，满足其一即可
		 * 1. 当vserver->pool不为空的时候
		 * 2. 当rule中没有对Host字段进行重写
		 **/
		if (vserver->pool[0] != 0) {
			fprintf(fp, "\t\t\tproxy_set_header Host $http_host;\n");
		} else if (vserver_rule_check_if_Host_Modified(vserver, rulequeue) == 0) {
			fprintf(fp, "\t\t\tproxy_set_header Host $http_host;\n");
		}

		/** location - rule **/
		if (!list_empty(&vserver->rule_head)) {
			if (!strcmp(vserver->contentswitch, "on") )
				print_rewrite_rules(fp, vserver, rulequeue, 3, 1);
			else
				print_rewrite_rules(fp, vserver, rulequeue, 3, 0);
		}

		/** location - normal proxy_pass **/
		if (strlen(vserver->pool)) {
			if (!strcmp(vserver->protocol, "https")) {
				if (!strcmp(vserver->ssl_offloading, "on"))
					fprintf(fp, "\t\t\tproxy_pass http://%s-%s;\n", vserver->name, vserver->pool);
				else
					fprintf(fp, "\t\t\tproxy_pass https://%s-%s;\n", vserver->name, vserver->pool);
			} else {
				fprintf(fp, "\t\t\tproxy_pass http://%s-%s;\n", vserver->name, vserver->pool);
			}
		}

#if 0
only_return_404:
		if (rserver_num <= 0) {
			fprintf(fp, "\t\t\treturn 404;\n");
		}
#endif

		fprintf(fp, "\t\t}\n");

		print_new_line(fp);

		if (!strcmp(vserver->protocol, "https")) {
			fprintf(fp, "\t\tssl on;\n");
			/*if (strlen(vserver->ssl_offloading))*/
			/*fprintf(fp, "\t\tssl_offloading %s;\n", vserver->ssl_offloading);*/
			/*if (strlen(vserver->sslaccelerator))*/
			/*fprintf(fp, "\t\tssl_accelerator %s;\n", vs->sslaccelerator);*/
			if (strlen(vserver->ssl_protocols) > 1) {

				strncpy(protocol, vserver->ssl_protocols, 32);
				ptr = protocol;
				while ((ptr = strchr(ptr, ',')) != NULL)
					*ptr = ' ';

				if (strstr(protocol, "TLSv1") != NULL) {
					strcat(protocol, " TLSv1.1 TLSv1.2");
				}

				fprintf(fp, "\t\tssl_protocols %s;\n", protocol);

				fprintf(fp, "\t\tssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:"
						"!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;\n");
				fprintf(fp, "\t\tssl_prefer_server_ciphers on;\n");
				fprintf(fp, "\t\tssl_session_cache shared:SSL:10m;\n");
				fprintf(fp, "\t\tssl_session_timeout 10m;\n");

			}

			if (strlen(vserver->ssl_certificate)) {
				fprintf(fp, "\t\tssl_certificate %s/%s/%s;\n",
						CERTTOP_DIR, vserver->ssl_certificate,
						certfile);
				fprintf(fp, "\t\tssl_certificate_key %s/%s/%s;\n",
						CERTTOP_DIR, vserver->ssl_certificate,
						keyfile);
				//fprintf(fp, "\t\tssl_ciphers ALL:!kEDH!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n");
				if (strlen(keypass) > 0) {
					fprintf(fp, "\t\tssl_certificate_key_password %s;\n", keypass);
				}
			}

				/* verify certificates grade, add@zhangly2014.7.3 */
				if (vserver->ssl_verify_depth[0] != '\0') {
					fprintf(fp, "\t\tssl_verify_depth %s;\n", vserver->ssl_verify_depth);
				}

			if (strlen(vserver->ssl_verify_client)) {
				/* verify client certificate */
				fprintf(fp, "\t\tssl_client_certificate %s/%s/%s;\n",
						CERTTOP_DIR, vserver->ssl_verify_client, ca);

				/* verify control */
				fprintf(fp, "\t\tssl_verify_client on;\n");

				if (strlen(vserver->ssl_crl)) {
					fprintf(fp, "\t\tssl_crl /SmartGrid/config/crl/%s;\n", vserver->ssl_crl);
				}
			}
		}

		if (vserver->errpage[0] != 0) {
			/** Error Pages **/
#if 0
			char buff[BUFSIZ];
			sprintf(buff, "cp -af /SmartGrid/config/errpages/%s /SmartGrid/smartl7/html/", vserver->errpage);
			system(buff);
#endif
			/* proxy requires this to be turned on  */
			fprintf(fp, "\t\tproxy_intercept_errors on;\n");

			fprintf(fp, "\t\terror_page 403 404 '/%s';\n", vserver->errpage);
			fprintf(fp, "\t\terror_page 502 503 504 '/%s';\n", vserver->errpage);
		}

		fprintf(fp, "\t}\n"); //end server block
	}

	if (valid_layer7_vserver > 0) {
		fprintf(fp, "\n"
				"\tserver {\n"
				"\t\tlisten 127.0.0.1:9099;\n"
				"\t\tserver_name conn_stat_server;\n"
				"\t\tlocation / {\n"
				"\t\t\tstat_enable on;\n"
				"\t\t}\n"
				"\t}\n");

		fprintf(fp, "}\n"); //end http block
	}

	fclose(fp);

	/** 如果修改后的文件与原始文件相同，则不通知smartl7进行配置更新 **/
	if (check_diff_file(filename, new) == 0) {
		unlink(new);
		return 0;
	}

	ret = check_config_file(new);
	if (ret < 0)
		goto bad;

	rename(filename, old);
	rename(new, filename);

	ret = signal_smartl7("reload", filename);
	if (ret < 0)
		goto bad;

	return 0;
bad:
	return -1;
}
